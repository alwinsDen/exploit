
use std::env;
use std::io;
use std::process;
use std::io::Write;

static VERSION: &str = "0.0.1";
// static mut TEMP : &str = "NO TEMP";

fn main() {
    intro_text();
    main_loop();
}
fn intro_text() {
    println!("Exploit {} created by Alwin T for {}.",VERSION,env::consts::OS);
    println!("Visit github https://github.com/alwinsDen/exploit");
}

fn main_loop() {
    loop {
        print!("{}","EXPLOIT@".to_owned() +VERSION+">> ");
        io::stdout().flush().unwrap();
        let mut input = String::new();
        io::stdin().read_line(&mut input)
            .expect("Wrong Input");
        let mut arg_vec : Vec<String> = input.split_whitespace()
            .map(|x| x.trim().to_string()). collect();
        if arg_vec[0] == "exit()" {
            exit_function();
        }
        //clear
        else if arg_vec[0] == "clear" {
            clearer();
        }
        //summation
        else if arg_vec[0] == "SUM" || arg_vec[0] == "sum" {
            arg_vec.retain(|x| x != "sum");
            summation(&arg_vec);
        }
        else if arg_vec[0] == "LOOP" || arg_vec[0] == "loop" {
            if arg_vec.len() == 3 {looping(&arg_vec);}
            else if arg_vec.len() == 4 {adv_looping(&arg_vec)}
            else {wrong_input()}
        }
        //for loop
        else if arg_vec[0] == "FOR" && arg_vec[arg_vec.len()-1]=="{" {
            for_loop_smp(&arg_vec);
        }
        //exit required input
        else {
            if arg_vec[0] == "exit" {println!("Use exit() or Ctrl+c to exit");continue;}
            wrong_input();
        }
    }
}

fn exit_function() {
    println!("Exiting Usurper {}",VERSION);
    process::exit(0);
}
fn wrong_input() { println!("{}","Failed to read the command."); }

fn clearer() { println!("{}","This function is barbaric") }

//summation function
fn summation(x : &Vec<String>) {
    let mut tot_sum :i128 = 0;
    for ele in x.iter() {
        if ele=="SUM" || ele=="+" {continue;};
        tot_sum += ele.parse::<i128>().unwrap();
    }
    println!("{}",tot_sum);
}

//simple looping
fn looping(x: &Vec<String>) {
    let mut count = 0;
    while count < x[1].parse::<i128>().unwrap() {
        println!("{}",x[2]);
        count += 1;
    }
}

//calculation looping
fn adv_looping(x: &Vec<String>) {
    if x[3]=="+" {
        let mut tot_sum : i128 = 0;
        for _ele in 0..x[1].parse::<i128>().unwrap() {
            tot_sum += x[2].parse::<i128>().unwrap();
        }
        println!("{}",tot_sum);
    }
    else if x[3]=="*" || x[3]=="x" || x[3]=="X" {
        let tot_mul = x[1].parse::<i128>().unwrap()*x[2].parse::<i128>().unwrap();
        println!("{}",tot_mul);
    }
    else {println!("Invalid Operator")};
}

//simple 'for' looping
fn for_loop_smp(_x: &Vec<String>) {
    // let mut for_loop_vec  = vec![];
    loop {
        print!("{}","             >>  ");
        // "             >>  "
        io::stdout().flush().unwrap();
        let mut for_arg = String::new();
        io::stdin().read_line(&mut for_arg)
            .expect("Input during execution");
        let proxy_arg = for_arg.trim();
        // for_loop_vec.push("sdf");
        // for_loop_vec.push(proxy_arg);
        if proxy_arg == "exit" {
            main_loop();
        }
        if proxy_arg == "}" {

            main_loop();
        }
    }
}